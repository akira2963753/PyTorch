"use strict";(self.webpackChunkanytype_publish_renderer=self.webpackChunkanytype_publish_renderer||[]).push([["4338"],{73318:function(e,t,n){n.d(t,{Z:()=>i});let i={buildUnableToPopLexerModeMessage:e=>`Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`,buildUnexpectedCharactersMessage:(e,t,n,i,r)=>`unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${n} characters.`}},66871:function(e,t,n){n.d(t,{h:()=>eu,B:()=>r});var i,r,o=n(55832),s=n(87317),a=n(18402),l=n(97345),h=n(66107),c=n(99561),u=n(18782),T=n(27884),d=n(61925),p=n(31739),f=n(46518),E=n(29072),_=n(35100),g=n(82633),m=n(73217),I=n(37627),N=n(96174),A=n(15877),O=n(11078),Z=n(15361),R=n(71134),C=n(2936),y=n(87074),L=n(52672),M=n(40675);let x={},P=new o.O;function k(e){let t=e.toString();if(x.hasOwnProperty(t))return x[t];{let e=P.pattern(t);return x[t]=e,e}}let S="Complement Sets are not supported for first char optimization",D='Unable to use "first char" lexer optimizations:\n';function v(e,t,n){let i=ee(e);t[i]=i,!0===n&&function(e,t){let n=String.fromCharCode(e),i=n.toUpperCase();if(i!==n){let e=ee(i.charCodeAt(0));t[e]=e}else{let e=n.toLowerCase();if(e!==n){let n=ee(e.charCodeAt(0));t[n]=n}}}(e,t)}function U(e,t){return(0,Z.Z)(e.value,e=>"number"==typeof e?(0,c.Z)(t,e):void 0!==(0,Z.Z)(t,t=>e.from<=t&&t<=e.to))}class b extends o.e{constructor(e){super(),this.targetCharCodes=e,this.found=!1}visitChildren(e){if(!0!==this.found){switch(e.type){case"Lookahead":this.visitLookahead(e);return;case"NegativeLookahead":this.visitNegativeLookahead(e);return}super.visitChildren(e)}}visitCharacter(e){(0,c.Z)(this.targetCharCodes,e.value)&&(this.found=!0)}visitSet(e){e.complement?void 0===U(e,this.targetCharCodes)&&(this.found=!0):void 0!==U(e,this.targetCharCodes)&&(this.found=!0)}}function w(e,t){if(!(t instanceof RegExp))return void 0!==(0,Z.Z)(t,t=>(0,c.Z)(e,t.charCodeAt(0)));{let n=k(t),i=new b(e);return i.visit(n),i.found}}let F="PATTERN",G="defaultMode",H="modes",$="boolean"==typeof RegExp("(?:)").sticky,z=/[^\\][$]/,B=/[^\\[][\^]|^\^/;function W(e){let t=e.ignoreCase?"i":"";return RegExp(`^(?:${e.source})`,t)}function K(e){let t=e.ignoreCase?"iy":"y";return RegExp(`${e.source}`,t)}function X(e){let t=e.PATTERN;if((0,h.Z)(t))return!1;if((0,u.Z)(t))return!0;if((0,E.Z)(t,"exec"))return!0;if((0,T.Z)(t))return!1;throw Error("non exhaustive match")}function V(e){return!!(0,T.Z)(e)&&1===e.length&&e.charCodeAt(0)}let Y={test:function(e){let t=e.length;for(let n=this.lastIndex;n<t;n++){let t=e.charCodeAt(n);if(10===t)return this.lastIndex=n+1,!0;if(13===t)return 10===e.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return!1},lastIndex:0};function j(e,t){if((0,E.Z)(e,"LINE_BREAKS"))return!1;if((0,h.Z)(e.PATTERN)){try{w(t,e.PATTERN)}catch(e){return{issue:r.IDENTIFY_TERMINATOR,errMsg:e.message}}return!1}if((0,T.Z)(e.PATTERN))return!1;if(X(e))return{issue:r.CUSTOM_LINE_BREAK};throw Error("non exhaustive match")}function q(e){return(0,l.Z)(e,e=>(0,T.Z)(e)?e.charCodeAt(0):e)}function Q(e,t,n){void 0===e[t]?e[t]=[n]:e[t].push(n)}let J=[];function ee(e){return e<256?e:J[e]}var et=n(47577),en=n(65521),ei=n(94675),er=n(6446),eo=n(59685),es=n(49133),ea=n(81724),el=n(90497),eh=n(73318);(i=r||(r={}))[i.MISSING_PATTERN=0]="MISSING_PATTERN",i[i.INVALID_PATTERN=1]="INVALID_PATTERN",i[i.EOI_ANCHOR_FOUND=2]="EOI_ANCHOR_FOUND",i[i.UNSUPPORTED_FLAGS_FOUND=3]="UNSUPPORTED_FLAGS_FOUND",i[i.DUPLICATE_PATTERNS_FOUND=4]="DUPLICATE_PATTERNS_FOUND",i[i.INVALID_GROUP_TYPE_FOUND=5]="INVALID_GROUP_TYPE_FOUND",i[i.PUSH_MODE_DOES_NOT_EXIST=6]="PUSH_MODE_DOES_NOT_EXIST",i[i.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",i[i.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",i[i.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",i[i.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",i[i.SOI_ANCHOR_FOUND=11]="SOI_ANCHOR_FOUND",i[i.EMPTY_MATCH_PATTERN=12]="EMPTY_MATCH_PATTERN",i[i.NO_LINE_BREAKS_FLAGS=13]="NO_LINE_BREAKS_FLAGS",i[i.UNREACHABLE_PATTERN=14]="UNREACHABLE_PATTERN",i[i.IDENTIFY_TERMINATOR=15]="IDENTIFY_TERMINATOR",i[i.CUSTOM_LINE_BREAK=16]="CUSTOM_LINE_BREAK",i[i.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE=17]="MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";let ec={deferDefinitionErrorsHandling:!1,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:["\n","\r"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:eh.Z,traceInitPerf:!1,skipValidations:!1,recoveryEnabled:!0};Object.freeze(ec);class eu{constructor(e,t=ec){if(this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},this.TRACE_INIT=(e,t)=>{if(!0!==this.traceInitPerf)return t();{this.traceInitIndent++;let n=Array(this.traceInitIndent+1).join("	");this.traceInitIndent<this.traceInitMaxIdent&&console.log(`${n}--> <${e}>`);let{time:i,value:r}=(0,es.H)(t),o=i>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&o(`${n}<-- <${e}> time: ${i}ms`),this.traceInitIndent--,r}},"boolean"==typeof t)throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");this.config=(0,et.Z)({},ec,t);let n=this.config.traceInitPerf;!0===n?(this.traceInitMaxIdent=1/0,this.traceInitPerf=!0):"number"==typeof n&&(this.traceInitMaxIdent=n,this.traceInitPerf=!0),this.traceInitIndent=-1,this.TRACE_INIT("Lexer Constructor",()=>{let n;let i=!0;this.TRACE_INIT("Lexer Config handling",()=>{if(this.config.lineTerminatorsPattern===ec.lineTerminatorsPattern)this.config.lineTerminatorsPattern=Y;else if(this.config.lineTerminatorCharacters===ec.lineTerminatorCharacters)throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");if(t.safeMode&&t.ensureOptimizations)throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking),(0,p.Z)(e)?n={modes:{defaultMode:(0,en.Z)(e)},defaultMode:G}:(i=!1,n=(0,en.Z)(e))}),!1===this.config.skipValidations&&(this.TRACE_INIT("performRuntimeChecks",()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(function(e,t,n){let i=[];return(0,E.Z)(e,G)||i.push({message:"A MultiMode Lexer cannot be initialized without a <"+G+"> property in its definition\n",type:r.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),(0,E.Z)(e,H)||i.push({message:"A MultiMode Lexer cannot be initialized without a <"+H+"> property in its definition\n",type:r.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),(0,E.Z)(e,H)&&(0,E.Z)(e,G)&&!(0,E.Z)(e.modes,e.defaultMode)&&i.push({message:`A MultiMode Lexer cannot be initialized with a ${G}: <${e.defaultMode}>which does not exist
`,type:r.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),(0,E.Z)(e,H)&&(0,g.Z)(e.modes,(e,t)=>{(0,g.Z)(e,(n,o)=>{if((0,d.Z)(n))i.push({message:`A Lexer cannot be initialized using an undefined Token Type. Mode:<${t}> at index: <${o}>
`,type:r.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});else if((0,E.Z)(n,"LONGER_ALT")){let o=(0,p.Z)(n.LONGER_ALT)?n.LONGER_ALT:[n.LONGER_ALT];(0,g.Z)(o,o=>{(0,d.Z)(o)||(0,c.Z)(e,o)||i.push({message:`A MultiMode Lexer cannot be initialized with a longer_alt <${o.name}> on token <${n.name}> outside of mode <${t}>
`,type:r.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE})})}})}),i}(n,this.trackStartLines,this.config.lineTerminatorCharacters))}),this.TRACE_INIT("performWarningRuntimeChecks",()=>{this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(function(e,t,n){let i=[],o=!1,s=(0,A.Z)((0,R.Z)((0,C.Z)(e.modes))),l=(0,a.Z)(s,e=>e[F]===eu.NA),h=q(n);return t&&(0,g.Z)(l,e=>{let t=j(e,h);if(!1!==t){let n={message:function(e,t){if(t.issue===r.IDENTIFY_TERMINATOR)return`Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${e.name}> Token Type
	 Root cause: ${t.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;if(t.issue===r.CUSTOM_LINE_BREAK)return`Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${e.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;throw Error("non exhaustive match")}(e,t),type:t.issue,tokenType:e};i.push(n)}else(0,E.Z)(e,"LINE_BREAKS")?!0===e.LINE_BREAKS&&(o=!0):w(h,e.PATTERN)&&(o=!0)}),t&&!o&&i.push({message:"Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",type:r.NO_LINE_BREAKS_FLAGS}),i}(n,this.trackStartLines,this.config.lineTerminatorCharacters))})),n.modes=n.modes?n.modes:{},(0,g.Z)(n.modes,(e,t)=>{n.modes[t]=(0,a.Z)(e,e=>(0,d.Z)(e))});let P=(0,y.Z)(n.modes);if((0,g.Z)(n.modes,(e,n)=>{this.TRACE_INIT(`Mode: <${n}> processing`,()=>{if(this.modes.push(n),!1===this.config.skipValidations&&this.TRACE_INIT("validatePatterns",()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(function(e,t){let n=[],i=function(e){let t=(0,I.Z)(e,e=>!(0,E.Z)(e,F));return{errors:(0,l.Z)(t,e=>({message:"Token Type: ->"+e.name+"<- missing static 'PATTERN' property",type:r.MISSING_PATTERN,tokenTypes:[e]})),valid:(0,N.Z)(e,t)}}(e);n=n.concat(i.errors);let s=function(e){let t=(0,I.Z)(e,e=>{let t=e[F];return!(0,h.Z)(t)&&!(0,u.Z)(t)&&!(0,E.Z)(t,"exec")&&!(0,T.Z)(t)});return{errors:(0,l.Z)(t,e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:r.INVALID_PATTERN,tokenTypes:[e]})),valid:(0,N.Z)(e,t)}}(i.valid),a=s.valid;return(n=(n=(n=(n=n.concat(s.errors)).concat(function(e){let t=[],n=(0,I.Z)(e,e=>(0,h.Z)(e[F]));return(t=(t=(t=(t=t.concat(function(e){class t extends o.e{constructor(){super(...arguments),this.found=!1}visitEndAnchor(e){this.found=!0}}let n=(0,I.Z)(e,e=>{let n=e.PATTERN;try{let e=k(n),i=new t;return i.visit(e),i.found}catch(e){return z.test(n.source)}});return(0,l.Z)(n,e=>({message:"Unexpected RegExp Anchor Error:\n	Token Type: ->"+e.name+"<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",type:r.EOI_ANCHOR_FOUND,tokenTypes:[e]}))}(n))).concat(function(e){class t extends o.e{constructor(){super(...arguments),this.found=!1}visitStartAnchor(e){this.found=!0}}let n=(0,I.Z)(e,e=>{let n=e.PATTERN;try{let e=k(n),i=new t;return i.visit(e),i.found}catch(e){return B.test(n.source)}});return(0,l.Z)(n,e=>({message:"Unexpected RegExp Anchor Error:\n	Token Type: ->"+e.name+"<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",type:r.SOI_ANCHOR_FOUND,tokenTypes:[e]}))}(n))).concat(function(e){let t=(0,I.Z)(e,e=>{let t=e[F];return t instanceof RegExp&&(t.multiline||t.global)});return(0,l.Z)(t,e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:r.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[e]}))}(n))).concat(function(e){let t=[],n=(0,l.Z)(e,n=>(0,_.Z)(e,(e,i)=>(n.PATTERN.source!==i.PATTERN.source||(0,c.Z)(t,i)||i.PATTERN===eu.NA||(t.push(i),e.push(i)),e),[]));n=(0,A.Z)(n);let i=(0,I.Z)(n,e=>e.length>1);return(0,l.Z)(i,e=>{let t=(0,l.Z)(e,e=>e.name),n=(0,O.Z)(e).PATTERN;return{message:`The same RegExp pattern ->${n}<-has been used in all of the following Token Types: ${t.join(", ")} <-`,type:r.DUPLICATE_PATTERNS_FOUND,tokenTypes:e}})}(n))).concat(function(e){let t=(0,I.Z)(e,e=>e.PATTERN.test(""));return(0,l.Z)(t,e=>({message:"Token Type: ->"+e.name+"<- static 'PATTERN' must not match an empty string",type:r.EMPTY_MATCH_PATTERN,tokenTypes:[e]}))}(n))}(a))).concat(function(e){let t=(0,I.Z)(e,e=>{if(!(0,E.Z)(e,"GROUP"))return!1;let t=e.GROUP;return t!==eu.SKIPPED&&t!==eu.NA&&!(0,T.Z)(t)});return(0,l.Z)(t,e=>({message:"Token Type: ->"+e.name+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:r.INVALID_GROUP_TYPE_FOUND,tokenTypes:[e]}))}(a))).concat(function(e,t){let n=(0,I.Z)(e,e=>void 0!==e.PUSH_MODE&&!(0,c.Z)(t,e.PUSH_MODE));return(0,l.Z)(n,e=>({message:`Token Type: ->${e.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${e.PUSH_MODE}<-which does not exist`,type:r.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[e]}))}(a,t))).concat(function(e){let t=[],n=(0,_.Z)(e,(e,t,n)=>{var i;let r=t.PATTERN;return r===eu.NA||((0,T.Z)(r)?e.push({str:r,idx:n,tokenType:t}):(0,h.Z)(r)&&(i=r,void 0===(0,Z.Z)([".","\\","[","]","|","^","$","(",")","?","*","+","{"],e=>-1!==i.source.indexOf(e)))&&e.push({str:r.source,idx:n,tokenType:t})),e},[]);return(0,g.Z)(e,(e,i)=>{(0,g.Z)(n,({str:n,idx:o,tokenType:s})=>{if(i<o&&function(e,t){if((0,h.Z)(t)){let n=t.exec(e);return null!==n&&0===n.index}if((0,u.Z)(t))return t(e,0,[],{});if((0,E.Z)(t,"exec"))return t.exec(e,0,[],{});if("string"==typeof t)return t===e;throw Error("non exhaustive match")}(n,e.PATTERN)){let n=`Token: ->${s.name}<- can never be matched.
Because it appears AFTER the Token Type ->${e.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;t.push({message:n,type:r.UNREACHABLE_PATTERN,tokenTypes:[e,s]})}})}),t}(a))}(e,P))}),(0,m.Z)(this.lexerDefinitionErrors)){let i;(0,el.s0)(e),this.TRACE_INIT("analyzeTokenTypes",()=>{i=function(e,t){let n,i,r,o,I,N,A,O,Z,R,y,x;let P=(t=(0,s.Z)(t,{useSticky:$,debug:!1,safeMode:!1,positionTracking:"full",lineTerminatorCharacters:["\r","\n"],tracer:(e,t)=>t()})).tracer;P("initCharCodeToOptimizedIndexMap",()=>{(function(){if((0,m.Z)(J)){J=Array(65536);for(let e=0;e<65536;e++)J[e]=e>255?255+~~(e/255):e}})()}),P("Reject Lexer.NA",()=>{n=(0,a.Z)(e,e=>e[F]===eu.NA)});let U=!1;P("Transform Patterns",()=>{U=!1,i=(0,l.Z)(n,e=>{let n=e[F];if((0,h.Z)(n)){let e=n.source;return 1!==e.length||"^"===e||"$"===e||"."===e||n.ignoreCase?2!==e.length||"\\"!==e[0]||(0,c.Z)(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],e[1])?t.useSticky?K(n):W(n):e[1]:e}if((0,u.Z)(n))return U=!0,{exec:n};if("object"==typeof n)return U=!0,n;if("string"==typeof n){if(1===n.length)return n;{let e=new RegExp(n.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&"));return t.useSticky?K(e):W(e)}}throw Error("non exhaustive match")})}),P("misc mapping",()=>{r=(0,l.Z)(n,e=>e.tokenTypeIdx),o=(0,l.Z)(n,e=>{let t=e.GROUP;if(t!==eu.SKIPPED){if((0,T.Z)(t))return t;if((0,d.Z)(t))return!1;throw Error("non exhaustive match")}}),I=(0,l.Z)(n,e=>{let t=e.LONGER_ALT;if(t)return(0,p.Z)(t)?(0,l.Z)(t,e=>(0,f.Z)(n,e)):[(0,f.Z)(n,t)]}),N=(0,l.Z)(n,e=>e.PUSH_MODE),A=(0,l.Z)(n,e=>(0,E.Z)(e,"POP_MODE"))}),P("Line Terminator Handling",()=>{let e=q(t.lineTerminatorCharacters);O=(0,l.Z)(n,e=>!1),"onlyOffset"!==t.positionTracking&&(O=(0,l.Z)(n,t=>(0,E.Z)(t,"LINE_BREAKS")?!!t.LINE_BREAKS:!1===j(t,e)&&w(e,t.PATTERN)))}),P("Misc Mapping #2",()=>{Z=(0,l.Z)(n,X),R=(0,l.Z)(i,V),y=(0,_.Z)(n,(e,t)=>{let n=t.GROUP;return(0,T.Z)(n)&&n!==eu.SKIPPED&&(e[n]=[]),e},{}),x=(0,l.Z)(i,(e,t)=>({pattern:i[t],longerAlt:I[t],canLineTerminator:O[t],isCustom:Z[t],short:R[t],group:o[t],push:N[t],pop:A[t],tokenTypeIdx:r[t],tokenType:n[t]}))});let b=!0,G=[];return t.safeMode||P("First Char Optimization",()=>{G=(0,_.Z)(n,(e,n,i)=>{if("string"==typeof n.PATTERN)Q(e,ee(n.PATTERN.charCodeAt(0)),x[i]);else if((0,p.Z)(n.START_CHARS_HINT)){let t;(0,g.Z)(n.START_CHARS_HINT,n=>{let r=ee("string"==typeof n?n.charCodeAt(0):n);t!==r&&(t=r,Q(e,r,x[i]))})}else if((0,h.Z)(n.PATTERN)){if(n.PATTERN.unicode)b=!1,t.ensureOptimizations&&(0,L.W)(`${D}	Unable to analyze < ${n.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);else{let r=function(e,t=!1){try{let t=k(e);return function e(t,n,i){switch(t.type){case"Disjunction":for(let r=0;r<t.value.length;r++)e(t.value[r],n,i);break;case"Alternative":let r=t.value;for(let t=0;t<r.length;t++){let o=r[t];switch(o.type){case"EndAnchor":case"GroupBackReference":case"Lookahead":case"NegativeLookahead":case"StartAnchor":case"WordBoundary":case"NonWordBoundary":continue}switch(o.type){case"Character":v(o.value,n,i);break;case"Set":if(!0===o.complement)throw Error(S);(0,g.Z)(o.value,e=>{if("number"==typeof e)v(e,n,i);else if(!0===i)for(let t=e.from;t<=e.to;t++)v(t,n,i);else{for(let t=e.from;t<=e.to&&t<256;t++)v(t,n,i);if(e.to>=256){let t=e.from>=256?e.from:256,i=e.to,r=ee(t),o=ee(i);for(let e=r;e<=o;e++)n[e]=e}}});break;case"Group":e(o.value,n,i);break;default:throw Error("Non Exhaustive Match")}let s=void 0!==o.quantifier&&0===o.quantifier.atLeast;if("Group"===o.type&&!1===function e(t){let n=t.quantifier;return!!n&&0===n.atLeast||!!t.value&&((0,p.Z)(t.value)?(0,M.Z)(t.value,e):e(t.value))}(o)||"Group"!==o.type&&!1===s)break}break;default:throw Error("non exhaustive match!")}return(0,C.Z)(n)}(t.value,{},t.flags.ignoreCase)}catch(n){if(n.message===S)t&&(0,L.r)(`${D}	Unable to optimize: < ${e.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);else{let n="";t&&(n="\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."),(0,L.W)(`${D}
	Failed parsing: < ${e.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues`+n)}}return[]}(n.PATTERN,t.ensureOptimizations);(0,m.Z)(r)&&(b=!1),(0,g.Z)(r,t=>{Q(e,t,x[i])})}}else t.ensureOptimizations&&(0,L.W)(`${D}	TokenType: <${n.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),b=!1;return e},[])}),{emptyGroups:y,patternIdxToConfig:x,charCodeToPatternIdxToConfig:G,hasCustom:U,canBeOptimized:b}}(e,{lineTerminatorCharacters:this.config.lineTerminatorCharacters,positionTracking:t.positionTracking,ensureOptimizations:t.ensureOptimizations,safeMode:t.safeMode,tracer:this.TRACE_INIT})}),this.patternIdxToConfig[n]=i.patternIdxToConfig,this.charCodeToPatternIdxToConfig[n]=i.charCodeToPatternIdxToConfig,this.emptyGroups=(0,et.Z)({},this.emptyGroups,i.emptyGroups),this.hasCustom=i.hasCustom||this.hasCustom,this.canModeBeOptimized[n]=i.canBeOptimized}})}),this.defaultMode=n.defaultMode,!(0,m.Z)(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling)throw Error("Errors detected in definition of Lexer:\n"+(0,l.Z)(this.lexerDefinitionErrors,e=>e.message).join("-----------------------\n"));(0,g.Z)(this.lexerDefinitionWarning,e=>{(0,L.r)(e.message)}),this.TRACE_INIT("Choosing sub-methods implementations",()=>{if($?(this.chopInput=ei.Z,this.match=this.matchWithTest):(this.updateLastIndex=er.Z,this.match=this.matchWithExec),i&&(this.handleModes=er.Z),!1===this.trackStartLines&&(this.computeNewColumn=ei.Z),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=er.Z),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else if(/onlyOffset/i.test(this.config.positionTracking))this.createTokenInstance=this.createOffsetOnlyToken;else throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);this.hasCustom?(this.addToken=this.addTokenUsingPush,this.handlePayload=this.handlePayloadWithCustom):(this.addToken=this.addTokenUsingMemberAccess,this.handlePayload=this.handlePayloadNoCustom)}),this.TRACE_INIT("Failed Optimization Warnings",()=>{let e=(0,_.Z)(this.canModeBeOptimized,(e,t,n)=>(!1===t&&e.push(n),e),[]);if(t.ensureOptimizations&&!(0,m.Z)(e))throw Error(`Lexer Modes: < ${e.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)}),this.TRACE_INIT("clearRegExpParserCache",()=>{x={}}),this.TRACE_INIT("toFastProperties",()=>{(0,ea.S)(this)})})}tokenize(e,t=this.defaultMode){if(!(0,m.Z)(this.lexerDefinitionErrors))throw Error("Unable to Tokenize because Errors detected in definition of Lexer:\n"+(0,l.Z)(this.lexerDefinitionErrors,e=>e.message).join("-----------------------\n"));return this.tokenizeInternal(e,t)}tokenizeInternal(e,t){let n,i,r,o,s,a,l,h,c,u,T,d,f,E,_,m,I;let N=e,A=N.length,O=0,Z=0,R=Array(this.hasCustom?0:Math.floor(e.length/10)),C=[],L=this.trackStartLines?1:void 0,M=this.trackStartLines?1:void 0,x=function(e){let t={},n=(0,y.Z)(e);return(0,g.Z)(n,n=>{let i=e[n];if((0,p.Z)(i))t[n]=[];else throw Error("non exhaustive match")}),t}(this.emptyGroups),P=this.trackStartLines,k=this.config.lineTerminatorsPattern,S=0,D=[],v=[],U=[],b=[];function w(){return D}function F(e){let t=v[ee(e)];return void 0===t?b:t}Object.freeze(b);let G=e=>{if(1===U.length&&void 0===e.tokenType.PUSH_MODE){let t=this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(e);C.push({offset:e.startOffset,line:e.startLine,column:e.startColumn,length:e.image.length,message:t})}else{U.pop();let e=(0,eo.Z)(U);D=this.patternIdxToConfig[e],v=this.charCodeToPatternIdxToConfig[e],S=D.length;let t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;m=v&&t?F:w}};function H(e){U.push(e),v=this.charCodeToPatternIdxToConfig[e],S=(D=this.patternIdxToConfig[e]).length,S=D.length;let t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;m=v&&t?F:w}H.call(this,t);let $=this.config.recoveryEnabled;for(;O<A;){a=null;let t=N.charCodeAt(O),p=m(t),g=p.length;for(n=0;n<g;n++){let i=(I=p[n]).pattern;l=null;let c=I.short;if(!1!==c?t===c&&(a=i):!0===I.isCustom?null!==(_=i.exec(N,O,R,x))?(a=_[0],void 0!==_.payload&&(l=_.payload)):a=null:(this.updateLastIndex(i,O),a=this.match(i,e,O)),null!==a){if(void 0!==(s=I.longerAlt)){let t=s.length;for(r=0;r<t;r++){let t=D[s[r]],n=t.pattern;if(h=null,!0===t.isCustom?null!==(_=n.exec(N,O,R,x))?(o=_[0],void 0!==_.payload&&(h=_.payload)):o=null:(this.updateLastIndex(n,O),o=this.match(n,e,O)),o&&o.length>a.length){a=o,l=h,I=t;break}}}break}}if(null!==a){if(c=a.length,void 0!==(u=I.group)&&(T=I.tokenTypeIdx,d=this.createTokenInstance(a,O,T,I.tokenType,L,M,c),this.handlePayload(d,l),!1===u?Z=this.addToken(R,Z,d):x[u].push(d)),e=this.chopInput(e,c),O+=c,M=this.computeNewColumn(M,c),!0===P&&!0===I.canLineTerminator){let e,t,n=0;k.lastIndex=0;do!0===(e=k.test(a))&&(t=k.lastIndex-1,n++);while(!0===e);0!==n&&(L+=n,M=c-t,this.updateTokenEndLineColumnLocation(d,u,t,n,L,M,c))}this.handleModes(I,G,H,d)}else{let t=O,n=L,r=M,o=!1===$;for(;!1===o&&O<A;)for(e=this.chopInput(e,1),O++,i=0;i<S;i++){let t=D[i],n=t.pattern,r=t.short;if(!1!==r?N.charCodeAt(O)===r&&(o=!0):!0===t.isCustom?o=null!==n.exec(N,O,R,x):(this.updateLastIndex(n,O),o=null!==n.exec(e)),!0===o)break}if(f=O-t,M=this.computeNewColumn(M,f),E=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(N,t,f,n,r),C.push({offset:t,line:n,column:r,length:f,message:E}),!1===$)break}}return this.hasCustom||(R.length=Z),{tokens:R,groups:x,errors:C}}handleModes(e,t,n,i){if(!0===e.pop){let r=e.push;t(i),void 0!==r&&n.call(this,r)}else void 0!==e.push&&n.call(this,e.push)}chopInput(e,t){return e.substring(t)}updateLastIndex(e,t){e.lastIndex=t}updateTokenEndLineColumnLocation(e,t,n,i,r,o,s){let a,l;void 0===t||(l=(a=n===s-1)?-1:0,1===i&&!0===a||(e.endLine=r+l,e.endColumn=o-1+-l))}computeNewColumn(e,t){return e+t}createOffsetOnlyToken(e,t,n,i){return{image:e,startOffset:t,tokenTypeIdx:n,tokenType:i}}createStartOnlyToken(e,t,n,i,r,o){return{image:e,startOffset:t,startLine:r,startColumn:o,tokenTypeIdx:n,tokenType:i}}createFullToken(e,t,n,i,r,o,s){return{image:e,startOffset:t,endOffset:t+s-1,startLine:r,endLine:r,startColumn:o,endColumn:o+s-1,tokenTypeIdx:n,tokenType:i}}addTokenUsingPush(e,t,n){return e.push(n),t}addTokenUsingMemberAccess(e,t,n){return e[t]=n,++t}handlePayloadNoCustom(e,t){}handlePayloadWithCustom(e,t){null!==t&&(e.payload=t)}matchWithTest(e,t,n){return!0===e.test(t)?t.substring(n,e.lastIndex):null}matchWithExec(e,t){let n=e.exec(t);return null!==n?n[0]:null}}eu.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.",eu.NA=/NOT_APPLICABLE/},90497:function(e,t,n){n.d(t,{A2:()=>g,QH:()=>d,VL:()=>I,gc:()=>p,s0:()=>_});var i=n(82633),r=n(65521),o=n(15877),s=n(71134),a=n(97345),l=n(96174),h=n(73217),c=n(31739),u=n(99561),T=n(29072);function d(e,t){let n=e.tokenTypeIdx;return n===t.tokenTypeIdx||!0===t.isParent&&!0===t.categoryMatchesMap[n]}function p(e,t){return e.tokenTypeIdx===t.tokenTypeIdx}let f=1,E={};function _(e){var t,n,d;let p=function(e){let t=(0,r.Z)(e),n=e,i=!0;for(;i;){n=(0,o.Z)((0,s.Z)((0,a.Z)(n,e=>e.CATEGORIES)));let e=(0,l.Z)(n,t);t=t.concat(e),(0,h.Z)(e)?i=!1:n=e}return t}(e);t=p,(0,i.Z)(t,e=>{var t,n;g(e)||(E[f]=e,e.tokenTypeIdx=f++),m(e)&&!(0,c.Z)(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),m(e)||(e.CATEGORIES=[]),t=e,(0,T.Z)(t,"categoryMatches")||(e.categoryMatches=[]),n=e,(0,T.Z)(n,"categoryMatchesMap")||(e.categoryMatchesMap={})}),n=p,(0,i.Z)(n,e=>{(function e(t,n){(0,i.Z)(t,e=>{n.categoryMatchesMap[e.tokenTypeIdx]=!0}),(0,i.Z)(n.CATEGORIES,i=>{let r=t.concat(n);(0,u.Z)(r,i)||e(r,i)})})([],e)}),d=p,(0,i.Z)(d,e=>{e.categoryMatches=[],(0,i.Z)(e.categoryMatchesMap,(t,n)=>{e.categoryMatches.push(E[n].tokenTypeIdx)})}),(0,i.Z)(p,e=>{e.isParent=e.categoryMatches.length>0})}function g(e){return(0,T.Z)(e,"tokenTypeIdx")}function m(e){return(0,T.Z)(e,"CATEGORIES")}function I(e){return(0,T.Z)(e,"tokenTypeIdx")}},31592:function(e,t,n){n.d(t,{V3:()=>g,WS:()=>h,dK:()=>N,ol:()=>A,r3:()=>l,sd:()=>I});var i=n(27884),r=n(61925),o=n(29072),s=n(66871),a=n(90497);function l(e){return h(e)?e.LABEL:e.name}function h(e){return(0,i.Z)(e.LABEL)&&""!==e.LABEL}let c="categories",u="label",T="group",d="push_mode",p="pop_mode",f="longer_alt",E="line_breaks",_="start_chars_hint";function g(e){return m(e)}function m(e){let t=e.pattern,n={};if(n.name=e.name,(0,r.Z)(t)||(n.PATTERN=t),(0,o.Z)(e,"parent"))throw"The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";return(0,o.Z)(e,c)&&(n.CATEGORIES=e[c]),(0,a.s0)([n]),(0,o.Z)(e,u)&&(n.LABEL=e[u]),(0,o.Z)(e,T)&&(n.GROUP=e[T]),(0,o.Z)(e,p)&&(n.POP_MODE=e[p]),(0,o.Z)(e,d)&&(n.PUSH_MODE=e[d]),(0,o.Z)(e,f)&&(n.LONGER_ALT=e[f]),(0,o.Z)(e,E)&&(n.LINE_BREAKS=e[E]),(0,o.Z)(e,_)&&(n.START_CHARS_HINT=e[_]),n}let I=m({name:"EOF",pattern:s.h.NA});function N(e,t,n,i,r,o,s,a){return{image:t,startOffset:n,endOffset:i,startLine:r,endLine:o,startColumn:s,endColumn:a,tokenTypeIdx:e.tokenTypeIdx,tokenType:e}}function A(e,t){return(0,a.QH)(e,t)}(0,a.s0)([I])}}]);
//# sourceMappingURL=4338.1bd85e0f7c2e4104.js.map